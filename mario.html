<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini Mario Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            font-family: 'Orbitron', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            animation: backgroundPulse 8s ease-in-out infinite alternate;
        }

        @keyframes backgroundPulse {
            0% {
                background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            }

            100% {
                background: linear-gradient(135deg, #16213e 0%, #1a1a2e 50%, #0c0c0c 100%);
            }
        }

        #gameContainer {
            position: relative;
            border: 3px solid #00d4ff;
            border-radius: 15px;
            box-shadow:
                0 0 30px #00d4ff,
                inset 0 0 20px rgba(0, 212, 255, 0.1);
            touch-action: none;
            background: linear-gradient(45deg, rgba(0, 212, 255, 0.05), rgba(255, 107, 107, 0.05));
            animation: containerGlow 3s ease-in-out infinite alternate;
            box-sizing: border-box; /* Added for correct full-screen sizing with border */
        }

        @keyframes containerGlow {
            0% {
                box-shadow: 0 0 30px #00d4ff, inset 0 0 20px rgba(0, 212, 255, 0.1);
            }

            100% {
                box-shadow: 0 0 50px #00d4ff, 0 0 80px rgba(0, 212, 255, 0.3), inset 0 0 30px rgba(0, 212, 255, 0.2);
            }
        }

        canvas {
            display: block;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
            border-radius: 12px;
        }

        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            border-radius: 12px;
            padding-top: 15px;
            padding-bottom: 15px;
            box-sizing: border-box;
        }

        #bottomHud {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: auto;
            gap: 5px;
        }

        .score-display {
            font-size: 24px;
            font-weight: 700;
            color: #00ff88;
            padding: 10px 20px;
            text-shadow: 0 0 10px #00ff88, 2px 2px 4px #000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(0, 255, 136, 0.1));
            border-radius: 20px;
            border: 2px solid #00ff88;
            backdrop-filter: blur(10px);
            animation: scoreGlow 2s ease-in-out infinite alternate;
            margin: 0 10px;
        }

        @keyframes scoreGlow {
            0% {
                text-shadow: 0 0 10px #00ff88, 2px 2px 4px #000;
            }

            100% {
                text-shadow: 0 0 20px #00ff88, 0 0 30px #00ff88, 2px 2px 4px #000;
            }
        }

        .health-display {
            font-size: 20px;
            font-weight: 700;
            color: #ff4757;
            text-shadow: 0 0 10px #ff4757, 1px 1px 3px #000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(255, 71, 87, 0.1));
            padding: 8px 15px;
            border-radius: 15px;
            border: 2px solid #ff4757;
            backdrop-filter: blur(10px);
            margin: 0 10px;
        }

        #mobileControls {
            display: none;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
        }

        #joystick {
            width: 130px;
            height: 130px;
            background: radial-gradient(circle, rgba(100, 100, 100, 0.4), rgba(50, 50, 50, 0.6));
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            border: 3px solid rgba(0, 212, 255, 0.7);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5), inset 0 0 20px rgba(255, 255, 255, 0.1);
        }

        #joystickNub {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle, #00d4ff, #0099cc);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
            transition: all 0.1s ease;
        }

        #jumpButton {
            width: 90px;
            height: 90px;
            background: radial-gradient(circle, #00ff88, #00cc6a);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: 900;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            border: 3px solid rgba(255, 255, 255, 0.8);
            user-select: none;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6), 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.1s ease;
        }

        #jumpButton:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.8), 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 26, 46, 0.9));
            color: #00ff88;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            font-size: 32px;
            font-weight: 900;
            border: 3px solid #00d4ff;
            z-index: 100;
            box-shadow:
                0 0 40px rgba(0, 212, 255, 0.6),
                inset 0 0 20px rgba(0, 255, 136, 0.1);
            backdrop-filter: blur(15px);
            animation: messageFloat 3s ease-in-out infinite alternate;
        }

        @keyframes messageFloat {
            0% {
                transform: translate(-50%, -50%) translateY(0px);
            }

            100% {
                transform: translate(-50%, -50%) translateY(-10px);
            }
        }

        .game-message button {
            font-family: 'Orbitron', 'Courier New', monospace;
            font-size: 22px;
            font-weight: 700;
            padding: 15px 30px;
            margin-top: 25px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow:
                0 0 20px rgba(0, 255, 136, 0.6),
                0 6px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .game-message button:hover {
            transform: translateY(-3px);
            box-shadow:
                0 0 30px rgba(0, 255, 136, 0.8),
                0 10px 25px rgba(0, 0, 0, 0.4);
        }

        .game-message button:active {
            transform: translateY(1px);
            box-shadow:
                0 0 15px rgba(0, 255, 136, 0.6),
                0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
        }

        @keyframes float {
            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-20px);
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="bottomHud">
                <div id="healthDisplay" class="health-display">‚ù§Ô∏è Health: 4</div>
                <div id="scoreDisplay" class="score-display">Score: 0 | Level: 1</div>
            </div>
            <div id="mobileControls">
                <div id="joystick">
                    <div id="joystickNub"></div>
                </div>
                <button id="jumpButton">JUMP</button>
            </div>
        </div>
        <div id="startScreen" class="game-message">
            üéÆ RETRO PIXEL PLATFORMER üéÆ
            <p style="font-size: 18px; color: #00d4ff;">Desktop: Arrow Keys + Space<br>Mobile: Touch Controls</p>
            <button id="startButton">Start Adventure</button>
            <p id="progressMessage" style="font-size: 16px; margin-top: 15px; color: #ffa502;"></p>
        </div>
        <div id="gameOverScreen" class="game-message" style="display: none;">
            üíÄ GAME OVER üíÄ
            <p id="gameOverScore"></p>
            <button id="restartButton">Try Again</button>
        </div>
        <div id="levelCompleteScreen" class="game-message" style="display: none;">
            <h2 id="levelCompleteTitle" style="margin-top: 0; margin-bottom: 15px;">üéâ LEVEL COMPLETE! üéâ</h2>
            <p id="levelCompleteScore" style="margin-bottom: 20px;"></p>
            <button id="nextLevelButton">Next Level</button>
            <button id="resetGameButtonFromVictory" style="display: none;">Play Again</button> 
        </div>
    </div>

    <audio id="soundtrack" loop></audio>
    <audio id="jumpSound"></audio>
    <audio id="damageSound"></audio>
    <audio id="gameOverSound"></audio>

    <script>
        const IS_TOUCH_DEVICE = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthDisplay = document.getElementById('healthDisplay');

        const mobileControls = document.getElementById('mobileControls');
        const joystick = document.getElementById('joystick');
        const joystickNub = document.getElementById('joystickNub');
        const jumpButton = document.getElementById('jumpButton');

        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const progressMessage = document.getElementById('progressMessage');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverScore = document.getElementById('gameOverScore');
        const restartButton = document.getElementById('restartButton');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const levelCompleteScore = document.getElementById('levelCompleteScore');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const resetGameButtonFromVictory = document.getElementById('resetGameButtonFromVictory'); // New button
        const levelCompleteTitle = document.getElementById('levelCompleteTitle'); // New title element

        // Audio elements
        // const soundtrack = document.getElementById('soundtrack'); // Not used with dummy sounds
        // const jumpSound = document.getElementById('jumpSound'); // Not used with dummy sounds
        // const damageSound = document.getElementById('damageSound'); // Not used with dummy sounds
        // const gameOverSound = document.getElementById('gameOverSound'); // Not used with dummy sounds

        // Web Audio API setup for dummy sounds
        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API is not supported in this browser. No dummy sounds will play.");
        }

        let mainSoundtrackOscillator = null; // Renamed from soundtrackOscillator

        function playTone(frequency, duration, volume = 0.1, type = 'sine', onendedCallback = null) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration / 1000);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration / 1000);
            if (onendedCallback) {
                oscillator.onended = onendedCallback;
            }
        }

        function playSweep(startFreq, endFreq, duration, volume = 0.1, type = 'sine', onendedCallback = null) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(endFreq, audioCtx.currentTime + duration / 1000); // Linear for more consistent sweep

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration / 1000);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration / 1000);
            if (onendedCallback) {
                oscillator.onended = onendedCallback;
            }
        }

        function playJumpSound() { // Renamed from playDummyJumpSound
            if (!audioCtx) return;
            playSweep(660, 1320, 120, 0.04, 'triangle'); // Short, quick rising pitch
        }

        function playDamageSound() { // Renamed from playDummyDamageSound
            if (!audioCtx) return;
            playTone(120, 250, 0.08, 'sawtooth'); // Rough, low tone
        }

        function playGameOverSound() { // Renamed from playDummyGameOverSound
            if (!audioCtx) return;
            // Sequence of three descending tones
            playTone(261, 200, 0.1, 'square', () => { // C4
                playTone(196, 200, 0.1, 'square', () => { // G3
                    playTone(130, 350, 0.1, 'square');    // C3
                });
            });
        }

        function playLevelWinSound() { // New function for level win
            if (!audioCtx) return;
            // A sequence of three rising tones
            playSweep(440, 880, 150, 0.07, 'triangle', () => { // A4 to A5
                playSweep(523, 1046, 150, 0.07, 'triangle', () => { // C5 to C6
                    playSweep(659, 1318, 200, 0.07, 'triangle');    // E5 to E6
                });
            });
        }

        function playGemCollectedSound() { // New function for gem collection
            if (!audioCtx) return;
            // Short, high-pitched, slightly metallic sine wave
            playTone(1396.91, 90, 0.03, 'sine'); // F#6
            setTimeout(() => {
                playTone(1760.00, 70, 0.02, 'sine'); // A6 - slightly delayed and softer for a shimmer
            }, 50);
        }

        function startSoundtrack() { // Renamed from startDummySoundtrack
            if (!audioCtx || mainSoundtrackOscillator) return; // Don't start if no context or already playing
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            mainSoundtrackOscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            mainSoundtrackOscillator.type = 'sine'; // A simple sine wave
            mainSoundtrackOscillator.frequency.setValueAtTime(65.41, audioCtx.currentTime); // Low C (C2)
            gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime); // Very quiet

            mainSoundtrackOscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            mainSoundtrackOscillator.start();
            // To make it "loop" or change, more complex logic would be needed here,
            // for now, it's a continuous low hum.
        }

        function stopSoundtrack() { // Renamed from stopDummySoundtrack
            if (mainSoundtrackOscillator) {
                mainSoundtrackOscillator.stop();
                mainSoundtrackOscillator.disconnect(); 
                mainSoundtrackOscillator = null;
            }
        }

        // REMOVE LATER - Old src lines:
        // soundtrack.src = "path/to/soundtrack.mp3";
        // jumpSound.src = "path/to/jump.wav";
        // damageSound.src = "path/to/damage.wav";
        // gameOverSound.src = "path/to/gameOver.wav";

        // Game constants
        const GRAVITY = 0.6;
        let PLAYER_SPEED; // Changed from const to let
        if (IS_TOUCH_DEVICE) {
            PLAYER_SPEED = 2.5; // Slower speed for mobile
        } else {
            PLAYER_SPEED = 4.5; // Original speed for desktop
        }
        const PLAYER_JUMP_FORCE = 13;
        const TILE_SIZE = 32;

        let player, platforms, gems, enemies, camera, particles;
        let score = 0;
        let currentLevel = 1;
        let totalGemsInLevel = 0;
        let collectedGemsInLevel = 0;
        let gameState = 'start';
        let screenShake = 0;
        let gameProgress = {
            level: 1,
            score: 0,
            health: 4 // Added health to default gameProgress
        }; // In-memory storage instead of localStorage

        // Enhanced timing
        let lastTime = 0;
        let deltaTime = 0;

        const keys = {
            left: false,
            right: false,
            up: false,
            space: false,
            joystickRequestsUp: false
        };

        // Enhanced colors with gradients and effects
        const COLORS = {
            player: '#ff6b6b',
            playerGlow: '#ff9999',
            platform: '#4a7c59',
            platformHighlight: '#5db370',
            gem: '#ffd700',
            gemGlow: '#ffed4a',
            enemy: '#9b59b6',
            enemyGlow: '#c44569',
            backgroundFar: '#34495e',
            backgroundNear: '#2ecc71',
            sky: '#1e3c72',
            particle: '#00d4ff'
        };

        // Particle system
        class Particle {
            constructor(x, y, vx = 0, vy = 0, color = COLORS.particle, life = 60) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 1;
                this.decay = 0.98;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.decay;
                this.vy *= this.decay;
                this.vy += 0.1; // Gravity
                this.life--;
                this.size *= 0.99;
            }

            draw(offsetX) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x - offsetX, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0 || this.size <= 0.1;
            }
        }

        // Enhanced Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = TILE_SIZE * 0.8;
                this.height = TILE_SIZE * 0.9;
                this.vx = 0;
                this.vy = 0;
                this.speed = PLAYER_SPEED;
                this.jumpForce = PLAYER_JUMP_FORCE;
                this.onGround = false;
                this.health = 4; // Changed from 3
                this.maxHealth = 4; // Changed from 3
                this.invulnerableTimer = 0;
                this.maxInvulnerableTime = 120;

                // Enhanced animation
                this.animState = 'idle';
                this.frameCount = 0;
                this.frameIndex = 0;
                this.frameDelay = 8;
                this.direction = 1;
                this.landingEffect = 0;
                this.jumpSquash = 1;
            }

            update() {
                // Enhanced movement with acceleration
                let targetVx = 0;
                if (keys.left) {
                    targetVx = -this.speed;
                    this.direction = -1;
                }
                if (keys.right) {
                    targetVx = this.speed;
                    this.direction = 1;
                }

                // Smooth acceleration/deceleration
                this.vx += (targetVx - this.vx) * 0.3;

                // Enhanced jumping with coyote time
                if ((keys.up || keys.space || keys.joystickRequestsUp) && this.onGround) { // Added keys.joystickRequestsUp
                    this.vy = -this.jumpForce;
                    this.onGround = false;
                    this.jumpSquash = 0.7; // Squash effect
                    // jumpSound.currentTime = 0; // Rewind to start // Not needed for Web Audio
                    // jumpSound.play(); // Old call
                    playJumpSound();

                    // Jump particles
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(
                            this.x + this.width / 2 + (Math.random() - 0.5) * this.width,
                            this.y + this.height,
                            (Math.random() - 0.5) * 6,
                            -Math.random() * 3,
                            '#00ff88',
                            30 + Math.random() * 20
                        ));
                    }
                }

                // Apply gravity
                this.vy += GRAVITY;

                // Squash and stretch recovery
                this.jumpSquash += (1 - this.jumpSquash) * 0.2;

                // Collision detection with improved response
                let nextX = this.x + this.vx;
                let nextY = this.y + this.vy;

                this.onGround = false;
                let wasOnGround = this.onGround;

                platforms.forEach(platform => {
                    // Horizontal collision
                    if (this.collidesWith(platform, nextX, this.y)) {
                        if (this.vx > 0) {
                            nextX = platform.x - this.width;
                        } else if (this.vx < 0) {
                            nextX = platform.x + platform.width;
                        }
                        this.vx *= 0.1; // Reduce bounce

                        // Wall hit particles
                        for (let i = 0; i < 3; i++) {
                            particles.push(new Particle(
                                this.vx > 0 ? this.x + this.width : this.x,
                                this.y + this.height / 2,
                                -this.vx * 0.5 + (Math.random() - 0.5) * 2,
                                (Math.random() - 0.5) * 4,
                                '#ffffff',
                                20
                            ));
                        }
                    }

                    // Vertical collision
                    if (this.collidesWith(platform, this.x, nextY)) {
                        if (this.vy > 0) { // Landing
                            nextY = platform.y - this.height;
                            if (!this.onGround && this.vy > 8) {
                                this.landingEffect = 10;
                                screenShake = 5;

                                // Landing particles
                                for (let i = 0; i < 12; i++) {
                                    particles.push(new Particle(
                                        this.x + Math.random() * this.width,
                                        this.y + this.height,
                                        (Math.random() - 0.5) * 8,
                                        -Math.random() * 6,
                                        '#8e44ad',
                                        40 + Math.random() * 20
                                    ));
                                }
                            }
                            this.onGround = true;
                            this.vy = 0;
                        } else if (this.vy < 0) {
                            nextY = platform.y + platform.height;
                            this.vy = 0;
                        }
                    }
                });

                this.x = nextX;
                this.y = nextY;

                // Enhanced bounds checking
                if (this.x < 0) this.x = 0;
                // Clamp player to the right edge of the world
                if (camera && camera.worldWidth !== undefined && (this.x + this.width > camera.worldWidth)) {
                    this.x = camera.worldWidth - this.width;
                    this.vx = 0; // Stop horizontal movement when hitting the world edge
                }

                // Fall damage
                if (this.y > canvas.height + 100) {
                    this.takeDamage(this.health); // Instant death
                }

                // Update effects
                if (this.invulnerableTimer > 0) {
                    this.invulnerableTimer--;
                }
                if (this.landingEffect > 0) {
                    this.landingEffect--;
                }

                this.updateAnimation();
            }

            updateAnimation() {
                this.frameCount++;
                if (this.frameCount >= this.frameDelay) {
                    this.frameCount = 0;
                    let maxFrames = this.animState === 'run' ? 4 : 2;
                    this.frameIndex = (this.frameIndex + 1) % maxFrames;
                }

                // Update animation state
                if (!this.onGround) {
                    this.animState = 'jump';
                } else if (Math.abs(this.vx) > 0.5) {
                    this.animState = 'run';
                } else {
                    this.animState = 'idle';
                }
            }

            draw(offsetX) {
                ctx.save();

                // Invulnerability flicker
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer / 6) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                let drawX = this.x - offsetX;
                let drawY = this.y;

                // Landing squash effect
                let squashY = this.landingEffect * 2;
                let stretchX = this.landingEffect * 0.1;

                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = COLORS.playerGlow;

                // Enhanced drawing with better animation
                ctx.fillStyle = COLORS.player;

                if (this.animState === 'idle') {
                    let breathe = Math.sin(this.frameCount * 0.1) * 2;
                    ctx.fillRect(drawX - stretchX, drawY + squashY - breathe, this.width + stretchX * 2, this.height - squashY + breathe);

                    // Idle animation details
                    if (this.frameIndex === 1) {
                        ctx.fillStyle = COLORS.playerGlow;
                        ctx.fillRect(drawX + this.width / 4, drawY - 3, this.width / 2, 3);
                    }
                } else if (this.animState === 'run') {
                    let bobY = Math.sin(this.frameIndex * Math.PI) * 3;
                    ctx.fillRect(drawX, drawY + bobY, this.width, this.height - Math.abs(bobY));

                    // Running particles
                    if (this.frameIndex === 0 && Math.random() < 0.3) {
                        particles.push(new Particle(
                            this.x + this.width / 2,
                            this.y + this.height,
                            -this.vx * 0.5 + (Math.random() - 0.5) * 2,
                            -Math.random() * 2,
                            '#ffffff',
                            15
                        ));
                    }
                } else if (this.animState === 'jump') {
                    let jumpScale = this.jumpSquash;
                    ctx.scale(1, jumpScale);
                    ctx.fillRect(drawX, drawY / jumpScale, this.width, this.height);
                    ctx.scale(1, 1 / jumpScale);
                }

                // Enhanced eye
                ctx.shadowBlur = 5;
                ctx.fillStyle = 'white';
                let eyeX = this.direction === 1 ? drawX + this.width * 0.65 : drawX + this.width * 0.15;
                ctx.fillRect(eyeX, drawY + this.height * 0.2, this.width * 0.2, this.height * 0.2);
                ctx.fillStyle = 'black';
                ctx.fillRect(eyeX + this.width * 0.05, drawY + this.height * 0.25, this.width * 0.1, this.height * 0.1);

                ctx.restore();
            }

            collidesWith(other, targetX = this.x, targetY = this.y) {
                return targetX < other.x + other.width &&
                    targetX + this.width > other.x &&
                    targetY < other.y + other.height &&
                    targetY + this.height > other.y;
            }

            takeDamage(amount) {
                if (this.invulnerableTimer > 0) return;

                this.health -= amount;
                healthDisplay.textContent = `‚ù§Ô∏è Health: ${this.health}`;
                this.invulnerableTimer = this.maxInvulnerableTime;
                screenShake = 15;

                // damageSound.currentTime = 0; // Rewind to start // Not needed
                // damageSound.play(); // Old call
                playDamageSound();

                // Damage particles
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        '#ff4757',
                        60
                    ));
                }

                if (this.health <= 0) {
                    gameState = 'gameOver';
                    gameOverScore.textContent = `Final Score: ${score}`;
                    gameOverScreen.style.display = 'block';
                    // soundtrack.pause(); // Old call
                    // soundtrack.currentTime = 0; // Old call
                    stopSoundtrack();
                    // gameOverSound.currentTime = 0; // Not needed
                    // gameOverSound.play(); // Old call
                    playGameOverSound();
                }
            }
        }

        // Enhanced Platform class
        class Platform {
            constructor(x, y, width, height, type = 'normal') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.animOffset = Math.random() * Math.PI * 2;
                this.goalPulse = 0;
            }

            draw(offsetX) {
                ctx.save();

                let glow = Math.sin(performance.now() * 0.002 + this.animOffset) * 5 + 10;

                if (this.type === 'goal') {
                    this.goalPulse += 0.08;

                    // Super bright glow effect
                    ctx.shadowBlur = glow + 20;
                    ctx.shadowColor = '#ff6b00';

                    // Rainbow cycling colors
                    let hue = (performance.now() * 0.1) % 360;
                    ctx.fillStyle = `hsl(${hue}, 90%, 65%)`;

                    // Draw main platform with pulsing effect
                    let pulseScale = 1 + Math.sin(this.goalPulse) * 0.1;
                    let pulseX = this.x - (this.width * (pulseScale - 1)) / 2;
                    let pulseY = this.y - (this.height * (pulseScale - 1)) / 2;
                    ctx.fillRect(pulseX - offsetX, pulseY, this.width * pulseScale, this.height * pulseScale);

                    // Add "FINISH" text
                    ctx.save();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Orbitron';
                    ctx.textAlign = 'center';
                    let textY = this.y - 10 + Math.sin(this.goalPulse * 2) * 5;
                    ctx.fillText('üèÅ FINISH üèÅ', this.x + this.width / 2 - offsetX, textY);
                    ctx.restore();

                    // Add collision debug box (larger than actual platform)
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(
                        this.x - 10 - offsetX,
                        this.y - 10,
                        this.width + 20,
                        this.height + 20
                    );
                    ctx.setLineDash([]);

                    // Add flag particles
                    if (Math.random() < 0.3) {
                        particles.push(new Particle(
                            this.x + Math.random() * this.width,
                            this.y - 20,
                            (Math.random() - 0.5) * 4,
                            -Math.random() * 5,
                            `hsl(${hue + Math.random() * 60}, 80%, 70%)`,
                            60
                        ));
                    }

                } else {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = COLORS.platformHighlight;
                    ctx.fillStyle = COLORS.platform;
                    ctx.fillRect(this.x - offsetX, this.y, this.width, this.height);
                }

                // Enhanced texture for normal platforms
                if (this.type !== 'goal') {
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    for (let i = 0; i < this.width / (TILE_SIZE / 2); i++) {
                        for (let j = 0; j < this.height / (TILE_SIZE / 2); j++) {
                            if ((i + j) % 2 === 0) {
                                ctx.fillRect(this.x - offsetX + i * TILE_SIZE / 2, this.y + j * TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2);
                            }
                        }
                    }
                }

                ctx.restore();
            }
        }

        // Enhanced Gem class
        class Gem {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = TILE_SIZE * 0.5;
                this.height = TILE_SIZE * 0.5;
                this.collected = false;
                this.animFrame = 0;
                this.animSpeed = 0.08;
                this.shineOffset = 0;
                this.rotation = 0;
                this.scale = 1;
            }

            update() {
                this.animFrame += this.animSpeed;
                this.shineOffset = Math.sin(this.animFrame) * 4;
                this.rotation += 0.05;
                this.scale = 1 + Math.sin(this.animFrame * 2) * 0.1;

                // Ambient particles
                if (Math.random() < 0.05) {
                    particles.push(new Particle(
                        this.x + this.width / 2 + (Math.random() - 0.5) * this.width,
                        this.y + this.height / 2 + (Math.random() - 0.5) * this.height,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        COLORS.gemGlow,
                        30
                    ));
                }
            }

            draw(offsetX) {
                if (this.collected) return;

                ctx.save();
                ctx.translate(this.x - offsetX + this.width / 2, this.y + this.height / 2 + this.shineOffset);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);

                ctx.shadowBlur = 20;
                ctx.shadowColor = COLORS.gemGlow;
                ctx.fillStyle = COLORS.gem;

                // Enhanced diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(this.width / 2, 0);
                ctx.lineTo(0, this.height / 2);
                ctx.lineTo(-this.width / 2, 0);
                ctx.closePath();
                ctx.fill();

                // Multiple shine effects
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(-this.width * 0.1, -this.height * 0.3, this.width * 0.2, this.height * 0.2);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(this.width * 0.1, this.height * 0.1, this.width * 0.15, this.height * 0.15);

                ctx.restore();
            }
        }

        // Enhanced Enemy class
        class Enemy {
            constructor(x, y, moveRange = 100) {
                this.x = x;
                this.y = y;
                this.width = TILE_SIZE * 0.9;
                this.height = TILE_SIZE * 0.7;
                this.startX = x;
                this.vx = 1.5;
                this.moveRange = moveRange;
                this.animFrame = 0;
                this.animSpeed = 0.08;
                this.hue = Math.random() * 360;
            }

            update() {
                this.x += this.vx;
                if (this.x > this.startX + this.moveRange || this.x < this.startX) {
                    this.vx *= -1;
                }
                this.animFrame += this.animSpeed;
                this.hue += 1;

                // Movement particles
                if (Math.random() < 0.1) {
                    particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height,
                        (Math.random() - 0.5) * 3,
                        -Math.random() * 2,
                        `hsl(${this.hue}, 70%, 60%)`,
                        25
                    ));
                }
            }

            draw(offsetX) {
                ctx.save();

                let pulse = Math.sin(this.animFrame * 3) * 0.1 + 1;
                ctx.shadowBlur = 15;
                ctx.shadowColor = COLORS.enemyGlow;

                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                let bodyHeight = this.height * pulse;
                ctx.fillRect(this.x - offsetX, this.y + (this.height - bodyHeight), this.width, bodyHeight);

                // Enhanced eyes with glow
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'white';
                if (this.vx > 0) {
                    ctx.fillRect(this.x - offsetX + this.width * 0.6, this.y + this.height * 0.2, 8, 8);
                    ctx.fillRect(this.x - offsetX + this.width * 0.75, this.y + this.height * 0.2, 8, 8);
                } else {
                    ctx.fillRect(this.x - offsetX + this.width * 0.15, this.y + this.height * 0.2, 8, 8);
                    ctx.fillRect(this.x - offsetX + this.width * 0.3, this.y + this.height * 0.2, 8, 8);
                }

                // Pupils
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'red';
                if (this.vx > 0) {
                    ctx.fillRect(this.x - offsetX + this.width * 0.62, this.y + this.height * 0.22, 4, 4);
                    ctx.fillRect(this.x - offsetX + this.width * 0.77, this.y + this.height * 0.22, 4, 4);
                } else {
                    ctx.fillRect(this.x - offsetX + this.width * 0.17, this.y + this.height * 0.22, 4, 4);
                    ctx.fillRect(this.x - offsetX + this.width * 0.32, this.y + this.height * 0.22, 4, 4);
                }

                ctx.restore();
            }
        }

        // Enhanced Camera class
        class Camera {
            constructor(worldWidth, worldHeight) {
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.width = canvas.width;
                this.height = canvas.height;
                this.worldWidth = worldWidth;
                this.worldHeight = worldHeight;
                this.smoothing = 1; // Changed to 1 for instant follow, ensuring player is centered (unless at world edge)
            }

            follow(target) {
                this.targetX = target.x + target.width / 2 - this.width / 2;
                let newX = this.x + (this.targetX - this.x) * this.smoothing;

                this.targetY = target.y + target.height / 2 - this.height / 2;
                let newY = this.y + (this.targetY - this.y) * this.smoothing; // if smoothing is 1, newY = targetY

                // Clamp camera X
                this.x = Math.max(0, Math.min(newX, this.worldWidth - this.width));

                // Clamp camera Y
                // Allow camera.y to be negative if newY is negative (to see items above world y=0).
                this.y = Math.min(newY, this.worldHeight - this.height);
            }

            update() {
                this.width = canvas.width;
                this.height = canvas.height;
            }
        }

        // Three challenging levels with progressive difficulty - MOVED TO BOTTOM
        const levels = [
            // Level 1 - Tutorial Level
            {
                name: "Forest Entrance",
                playerStart: {
                    x: 50,
                    y: canvas.height - TILE_SIZE * 2
                },
                platforms: [{
                        x: 0,
                        y: canvas.height - TILE_SIZE * 0.5,
                        width: TILE_SIZE * 10,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 12,
                        y: canvas.height - TILE_SIZE * 0.5,
                        width: TILE_SIZE * 10,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 6,
                        y: canvas.height - TILE_SIZE * 2.5,
                        width: TILE_SIZE * 4,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 15,
                        y: canvas.height - TILE_SIZE * 3,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 23,
                        y: canvas.height - TILE_SIZE * 0.5,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE,
                        type: 'goal'
                    }
                ],
                gems: [{
                        x: TILE_SIZE * 7,
                        y: canvas.height - TILE_SIZE * 3.5
                    },
                    {
                        x: TILE_SIZE * 13,
                        y: canvas.height - TILE_SIZE * 1.5
                    },
                    {
                        x: TILE_SIZE * 16,
                        y: canvas.height - TILE_SIZE * 4
                    },
                ],
                enemies: [{
                    x: TILE_SIZE * 13,
                    y: canvas.height - TILE_SIZE * 1.2,
                    range: TILE_SIZE * 3
                }, ],
                worldWidth: TILE_SIZE * 25
            },
            // Level 2 - Mountain Pass
            {
                name: "Mountain Pass",
                playerStart: {
                    x: 30,
                    y: canvas.height - TILE_SIZE * 3.5
                },
                platforms: [{
                        x: 0,
                        y: canvas.height - TILE_SIZE * 2,
                        width: TILE_SIZE * 5,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 8,
                        y: canvas.height - TILE_SIZE * 1,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 12,
                        y: canvas.height - TILE_SIZE * 2.5,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 7,
                        y: canvas.height - TILE_SIZE * 4.5,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 15,
                        y: canvas.height - TILE_SIZE * 0.5,
                        width: TILE_SIZE * 10,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 26,
                        y: canvas.height - TILE_SIZE * 2,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE,
                        type: 'goal'
                    }
                ],
                gems: [{
                        x: TILE_SIZE * 9,
                        y: canvas.height - TILE_SIZE * 2
                    },
                    {
                        x: TILE_SIZE * 13,
                        y: canvas.height - TILE_SIZE * 3.5
                    },
                    {
                        x: TILE_SIZE * 7.5,
                        y: canvas.height - TILE_SIZE * 5.5
                    },
                    {
                        x: TILE_SIZE * 18,
                        y: canvas.height - TILE_SIZE * 1.5
                    },
                    {
                        x: TILE_SIZE * 22,
                        y: canvas.height - TILE_SIZE * 1.5
                    },
                ],
                enemies: [{
                        x: TILE_SIZE * 16,
                        y: canvas.height - TILE_SIZE * 1.2,
                        range: TILE_SIZE * 6
                    },
                    {
                        x: TILE_SIZE * 2,
                        y: canvas.height - TILE_SIZE * 2.7,
                        range: TILE_SIZE * 1.5
                    },
                ],
                worldWidth: TILE_SIZE * 30
            },
            // Level 3 - Sky Temple (Final Level)
            {
                name: "Sky Temple",
                playerStart: {
                    x: 40,
                    y: canvas.height - TILE_SIZE * 1.5
                },
                platforms: [{
                        x: 0,
                        y: canvas.height - TILE_SIZE * 0.5,
                        width: TILE_SIZE * 6,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 9,
                        y: canvas.height - TILE_SIZE * 2,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 13,
                        y: canvas.height - TILE_SIZE * 3,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 5,
                        y: canvas.height - TILE_SIZE * 4,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 17,
                        y: canvas.height - TILE_SIZE * 4.5,
                        width: TILE_SIZE * 2,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 10,
                        y: canvas.height - TILE_SIZE * 5.5,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 21,
                        y: canvas.height - TILE_SIZE * 3.5,
                        width: TILE_SIZE * 4,
                        height: TILE_SIZE * 0.5
                    },
                    {
                        x: TILE_SIZE * 27,
                        y: canvas.height - TILE_SIZE * 2,
                        width: TILE_SIZE * 5,
                        height: TILE_SIZE
                    },
                    {
                        x: TILE_SIZE * 34,
                        y: canvas.height - TILE_SIZE * 4.5,
                        width: TILE_SIZE * 3,
                        height: TILE_SIZE,
                        type: 'goal'
                    }
                ],
                gems: [{
                        x: TILE_SIZE * 10,
                        y: canvas.height - TILE_SIZE * 2.5
                    },
                    {
                        x: TILE_SIZE * 14,
                        y: canvas.height - TILE_SIZE * 4
                    },
                    {
                        x: TILE_SIZE * 6.5,
                        y: canvas.height - TILE_SIZE * 5
                    },
                    {
                        x: TILE_SIZE * 18,
                        y: canvas.height - TILE_SIZE * 5.5
                    },
                    {
                        x: TILE_SIZE * 11.5,
                        y: canvas.height - TILE_SIZE * 6.5
                    },
                    {
                        x: TILE_SIZE * 23,
                        y: canvas.height - TILE_SIZE * 4.5
                    },
                    {
                        x: TILE_SIZE * 29,
                        y: canvas.height - TILE_SIZE * 3
                    },
                ],
                enemies: [{
                        x: TILE_SIZE * 28,
                        y: canvas.height - TILE_SIZE * 2.7,
                        range: TILE_SIZE * 3
                    },
                    {
                        x: TILE_SIZE * 22,
                        y: canvas.height - TILE_SIZE * 4.2,
                        range: TILE_SIZE * 2
                    },
                    {
                        x: TILE_SIZE * 11,
                        y: canvas.height - TILE_SIZE * 6.2,
                        range: TILE_SIZE * 1.5
                    },
                ],
                worldWidth: TILE_SIZE * 40
            }
        ];

        function loadLevel(levelNumber) {
            if (levelNumber > levels.length) {
                gameState = 'gameComplete';
                
                levelCompleteTitle.textContent = "üèÜ EPIC VICTORY! üèÜ";
                levelCompleteScore.innerHTML = `
                    <br>üéâ YOU CONQUERED ALL ${levels.length} LEVELS! üéâ
                    <br><p style="font-size: 18px; color: #00d4ff; margin: 15px 0;">
                        Final Score: ${score}<br>
                        You are a true platforming master!
                    </p>`;
                
                nextLevelButton.style.display = 'none';
                resetGameButtonFromVictory.style.display = 'inline-block'; // or 'block' depending on desired layout
                levelCompleteScreen.style.display = 'block';
                
                // soundtrack.pause(); // Stop soundtrack on ultimate victory // Old call
                // soundtrack.currentTime = 0; // Old call
                stopSoundtrack();
                playLevelWinSound(); // Play win sound for final victory too
                // Potentially play a victory sound here if you add one

                // The onclick for resetGameButtonFromVictory is already set in init()
                return;
            }

            const levelData = levels[levelNumber - 1];
            player = new Player(levelData.playerStart.x, levelData.playerStart.y);

            // Set player health from gameProgress, or default to maxHealth
            if (gameProgress && gameProgress.health !== undefined) {
                player.health = gameProgress.health;
            } else {
                player.health = player.maxHealth; // Should be 4, as defined in Player constructor
            }

            platforms = levelData.platforms.map(p => new Platform(p.x, p.y, p.width, p.height, p.type));
            gems = levelData.gems.map(g => new Gem(g.x, g.y));
            enemies = levelData.enemies.map(e => new Enemy(e.x, e.y, e.range));
            particles = [];

            camera = new Camera(levelData.worldWidth, canvas.height);
            totalGemsInLevel = gems.length;
            collectedGemsInLevel = 0;

            scoreDisplay.textContent = `Score: ${score} | Level: ${currentLevel} - ${levelData.name}`;
            healthDisplay.textContent = `‚ù§Ô∏è Health: ${player.health}`;
            levelCompleteScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none';
            gameState = 'playing';
        }

        function update(currentTime) {
            if (gameState !== 'playing') return;

            deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            player.update();
            enemies.forEach(enemy => enemy.update());
            gems.forEach(gem => gem.update());

            // Update particles
            particles.forEach(particle => particle.update());
            particles = particles.filter(particle => !particle.isDead());

            // Check gem collection with enhanced effects
            gems.forEach((gem, index) => {
                if (!gem.collected && player.collidesWith(gem)) {
                    gem.collected = true;
                    score += 100;
                    collectedGemsInLevel++;
                    scoreDisplay.textContent = `Score: ${score} | Level: ${currentLevel}`;
                    playGemCollectedSound(); // Play gem collection sound

                    // Collection particles
                    for (let i = 0; i < 20; i++) {
                        particles.push(new Particle(
                            gem.x + gem.width / 2,
                            gem.y + gem.height / 2,
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8,
                            COLORS.gemGlow,
                            60
                        ));
                    }

                    screenShake = 3;
                }
            });

            // Check enemy collision
            enemies.forEach(enemy => {
                if (player.collidesWith(enemy)) {
                    player.takeDamage(1);
                }
            });

            // Check goal platform collision - IMPROVED WITH DEBUGGING
            platforms.forEach(platform => {
                if (platform.type === 'goal') {
                    // Multiple collision detection methods for reliability
                    const simpleCollision = player.collidesWith(platform);

                    // Expanded bounding box collision
                    const expandedCollision =
                        player.x < platform.x + platform.width + 10 &&
                        player.x + player.width > platform.x - 10 &&
                        player.y < platform.y + platform.height + 10 &&
                        player.y + player.height > platform.y - 10;

                    // Distance-based collision (very forgiving)
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const platformCenterX = platform.x + platform.width / 2;
                    const platformCenterY = platform.y + platform.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(playerCenterX - platformCenterX, 2) +
                        Math.pow(playerCenterY - platformCenterY, 2)
                    );
                    const distanceCollision = distance < (TILE_SIZE * 1.5);

                    // If ANY collision method triggers
                    if (simpleCollision || expandedCollision || distanceCollision) {
                        console.log('GOAL COLLISION DETECTED!', {
                            level: currentLevel,
                            simpleCollision,
                            expandedCollision,
                            distanceCollision,
                            distance,
                            playerPos: {
                                x: player.x,
                                y: player.y
                            },
                            platformPos: {
                                x: platform.x,
                                y: platform.y
                            }
                        });

                        const currentLevelData = levels[currentLevel - 1];
                        gameState = 'levelComplete';

                        // Create level completion message
                        if (currentLevel < levels.length) {
                            levelCompleteTitle.textContent = `üéâ ${currentLevelData.name.toUpperCase()} COMPLETE! üéâ`;
                            levelCompleteScore.innerHTML = `
                                <p style="font-size: 18px; color: #00d4ff; margin: 10px 0;">
                                    Score: ${score}<br>
                                    Gems Collected: ${collectedGemsInLevel}/${totalGemsInLevel}
                                </p>`;
                            nextLevelButton.textContent = "Next Level";
                        } else { // This means currentLevel === levels.length (last normal level)
                            levelCompleteTitle.textContent = "üéä FINAL LEVEL COMPLETE! üéä";
                            levelCompleteScore.innerHTML = `
                                <p style="font-size: 18px; color: #00d4ff; margin: 10px 0;">
                                    Score: ${score}<br>
                                    All ${levels.length} adventures conquered so far!
                                </p>`;
                            nextLevelButton.textContent = "Finish Game"; // Clicking this will lead to EPIC VICTORY screen via loadLevel(currentLevel+1)
                        }

                        nextLevelButton.style.display = 'inline-block'; // or 'block'
                        resetGameButtonFromVictory.style.display = 'none';
                        levelCompleteScreen.style.display = 'block';
                        
                        playLevelWinSound(); // Play level win sound

                        gameProgress.level = currentLevel + 1;
                        gameProgress.score = score;
                        gameProgress.health = player.health; // Save current health

                        localStorage.setItem('retroPixelSave', JSON.stringify(gameProgress));

                        // Victory particles
                        for (let i = 0; i < 50; i++) {
                            particles.push(new Particle(
                                player.x + player.width / 2,
                                player.y + player.height / 2,
                                (Math.random() - 0.5) * 15,
                                (Math.random() - 0.5) * 15,
                                `hsl(${Math.random() * 360}, 70%, 60%)`,
                                100
                            ));
                        }

                        // Add bonus score for level completion
                        score += 500;
                        scoreDisplay.textContent = `Score: ${score} | Level: ${currentLevel} - ${currentLevelData.name}`;

                        console.log(`Level ${currentLevel} completed! Moving to level ${currentLevel + 1}`);
                        return; // Exit the loop once goal is reached
                    }

                    // Debug: Show distance to goal when close
                    if (distance < TILE_SIZE * 3) {
                        console.log(`Close to goal! Distance: ${Math.round(distance)}, Position: (${Math.round(player.x)}, ${Math.round(player.y)})`);
                    }
                }
            });

            if (camera) {
                camera.update();
                camera.follow(player);
            }

            // Decay screenShake after all updates that might trigger it
            if (screenShake > 0) {
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
        }

        function drawEnhancedParallaxBackground(camX, camY) {
            // Animated gradient sky
            let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            let time = performance.now() * 0.001;

            // Normalized time for sky gradient animation to prevent large input to Math.sin()
            const skyAnimationCycleDurationSeconds = 3600; // 1 hour, a long period for the cycle
            let normalizedSkyTime = time % skyAnimationCycleDurationSeconds;

            skyGradient.addColorStop(0, `hsl(${220 + Math.sin(normalizedSkyTime * 0.5) * 10}, 60%, ${30 + Math.sin(normalizedSkyTime * 0.3) * 5}%)`);
            skyGradient.addColorStop(0.7, `hsl(${250 + Math.sin(normalizedSkyTime * 0.7) * 15}, 70%, ${40 + Math.sin(normalizedSkyTime * 0.4) * 8}%)`);
            skyGradient.addColorStop(1, `hsl(${280 + Math.sin(normalizedSkyTime * 0.6) * 12}, 80%, ${50 + Math.sin(normalizedSkyTime * 0.2) * 10}%)`);

            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Enhanced parallax layers
            let farSpeed = 0.1;
            let midSpeed = 0.3;
            let nearSpeed = 0.6;

            // Vertical scroll amounts based on layer speed and camY
            let verticalScrollFar = camY * farSpeed;
            let verticalScrollMid = camY * midSpeed;
            let verticalScrollNear = camY * nearSpeed;

            // Stars (using camX for horizontal parallax, Y positions are viewport relative for distance)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 100; i++) {
                let starX = (i * 37 + camX * farSpeed * 0.1) % (canvas.width + 100) - 50;
                let starY = (i * 23) % canvas.height; // Stars remain relative to viewport Y for depth
                let twinkle = Math.sin(time + i) * 0.5 + 0.5;
                ctx.globalAlpha = twinkle;
                ctx.fillRect(starX, starY, 2, 2);
            }
            ctx.globalAlpha = 1;

            // Far mountains with gradient
            ctx.save();
            for (let i = -2; i < 3; i++) {
                let mountainGradient = ctx.createLinearGradient(0, canvas.height * 0.4 - verticalScrollFar, 0, canvas.height - verticalScrollFar);
                mountainGradient.addColorStop(0, `hsl(${220 + i * 10}, 40%, 25%)`);
                mountainGradient.addColorStop(1, `hsl(${240 + i * 10}, 50%, 15%)`);

                ctx.fillStyle = mountainGradient;
                ctx.beginPath();
                ctx.moveTo((i * canvas.width) - camX * farSpeed, canvas.height - verticalScrollFar);
                ctx.lineTo((i * canvas.width) - camX * farSpeed, canvas.height * 0.6 - verticalScrollFar);
                ctx.lineTo((i * canvas.width + canvas.width * 0.2) - camX * farSpeed, canvas.height * 0.4 - verticalScrollFar);
                ctx.lineTo((i * canvas.width + canvas.width * 0.5) - camX * farSpeed, canvas.height * 0.7 - verticalScrollFar);
                ctx.lineTo((i * canvas.width + canvas.width * 0.8) - camX * farSpeed, canvas.height * 0.5 - verticalScrollFar);
                ctx.lineTo((i * canvas.width + canvas.width) - camX * farSpeed, canvas.height * 0.65 - verticalScrollFar);
                ctx.lineTo((i * canvas.width + canvas.width) - camX * farSpeed, canvas.height - verticalScrollFar);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();

            // Mid-layer hills
            ctx.save();
            for (let i = -2; i < 3; i++) {
                let hillGradient = ctx.createLinearGradient(0, canvas.height * 0.7 - verticalScrollMid, 0, canvas.height - verticalScrollMid);
                hillGradient.addColorStop(0, COLORS.backgroundNear);
                hillGradient.addColorStop(1, `hsl(${140}, 50%, 40%)`);

                ctx.fillStyle = hillGradient;
                ctx.beginPath();
                ctx.moveTo((i * canvas.width) - camX * midSpeed, canvas.height - verticalScrollMid);
                ctx.lineTo((i * canvas.width) - camX * midSpeed, canvas.height * 0.8 - verticalScrollMid);
                ctx.quadraticCurveTo(
                    (i * canvas.width + canvas.width * 0.25) - camX * midSpeed, canvas.height * 0.7 - verticalScrollMid,
                    (i * canvas.width + canvas.width * 0.5) - camX * midSpeed, canvas.height * 0.85 - verticalScrollMid
                );
                ctx.quadraticCurveTo(
                    (i * canvas.width + canvas.width * 0.75) - camX * midSpeed, canvas.height * 0.95 - verticalScrollMid,
                    (i * canvas.width + canvas.width) - camX * midSpeed, canvas.height * 0.8 - verticalScrollMid
                );
                ctx.lineTo((i * canvas.width + canvas.width) - camX * midSpeed, canvas.height - verticalScrollMid);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();

            // Enhanced trees with depth
            for (let i = -2; i < 3; i++) {
                for (let t = 0; t < 8; t++) {
                    let treeX = (i * canvas.width + t * canvas.width / 8 + Math.sin(t * 2 + time * 0.5) * 20) - camX * nearSpeed;
                    let treeBaseYScreen = canvas.height * 0.8 + Math.sin(t + time * 0.3) * 15;
                    let treeSize = 0.8 + Math.sin(t + time * 0.2) * 0.3;

                    // Adjusted Y positions for trees based on verticalScrollNear
                    let currentTreeBaseY = treeBaseYScreen - verticalScrollNear;

                    // Tree trunk with gradient
                    let trunkGradient = ctx.createLinearGradient(treeX + 20, currentTreeBaseY - 40 * treeSize, treeX + 20, currentTreeBaseY);
                    trunkGradient.addColorStop(0, '#8B4513');
                    trunkGradient.addColorStop(1, '#5D2E08');

                    ctx.fillStyle = trunkGradient;
                    ctx.fillRect(treeX + 15, currentTreeBaseY - 40 * treeSize, 10 * treeSize, 40 * treeSize);

                    // Tree top with glow
                    ctx.save();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.backgroundNear;
                    ctx.fillStyle = `hsl(${120 + Math.sin(t + time * 0.1) * 20}, 60%, 40%)`;
                    ctx.beginPath();
                    ctx.arc(treeX + 20, currentTreeBaseY - 50 * treeSize, 25 * treeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let camX = camera ? camera.x : 0;
            let camY = camera ? camera.y : 0;

            // Draw enhanced background first, handling its own parallax relative to screen coordinates
            drawEnhancedParallaxBackground(camX, camY);

            ctx.save();
            ctx.translate(-camX, -camY); // Translate to camera's world view (unshaken)

            // Apply screen shake to the world rendering (foreground elements)
            let appliedShakeX = 0;
            let appliedShakeY = 0;
            if (screenShake > 0) {
                appliedShakeX = (Math.random() - 0.5) * screenShake;
                appliedShakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(appliedShakeX, appliedShakeY);
            }

            // Draw game objects - they are drawn at their world coordinates
            // as the context is already translated by camera and shake.
            // Pass 0 for offsetX as it's handled by the context translation.
            platforms.forEach(platform => platform.draw(0));
            gems.forEach(gem => gem.draw(0));
            enemies.forEach(enemy => enemy.draw(0));
            particles.forEach(particle => particle.draw(0)); 
            if (player) player.draw(0);

            // Debug: Show proximity to goal platforms
            if (player && gameState === 'playing') {
                platforms.forEach(platform => {
                    if (platform.type === 'goal') {
                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;
                        const platformCenterX = platform.x + platform.width / 2;
                        const platformCenterY = platform.y + platform.height / 2;
                        const distance = Math.sqrt(
                            Math.pow(playerCenterX - platformCenterX, 2) +
                            Math.pow(playerCenterY - platformCenterY, 2)
                        );

                        // Show proximity indicator - lines and text drawn in world coordinates
                        // (which are now correctly transformed by camera + shake)
                        if (distance < TILE_SIZE * 3) {
                            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(playerCenterX, playerCenterY);
                            ctx.lineTo(platformCenterX, platformCenterY);
                            ctx.stroke();

                            ctx.fillStyle = 'white';
                            ctx.font = '12px Arial';
                            ctx.fillText(`${Math.round(distance)}px`, 
                                         (playerCenterX + platformCenterX) / 2, 
                                         (playerCenterY + platformCenterY) / 2);
                        }
                    }
                });
            }

            ctx.restore(); // Restores to pre-camera and pre-shake translation state
        }

        let animationId;

        function gameLoop(timestamp) {
            if (gameState === 'playing') {
                update(timestamp);
            }
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        // Enhanced input handling
        function handleKeyDown(e) {
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = true;
                    break;
                case ' ':
                case 'Spacebar':
                    keys.space = true;
                    e.preventDefault();
                    break;
            }
        }

        function handleKeyUp(e) {
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = false;
                    break;
                case ' ':
                case 'Spacebar':
                    keys.space = false;
                    break;
            }
        }

        // Enhanced mobile controls
        let joystickActive = false;
        let joystickTouchId = null;
        let joystickCenterX, joystickCenterY, joystickRadius;

        function setupMobileControls() {
            const uiLayer = gameContainer.querySelector('#uiLayer'); 
            // const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); DELETED - using global
            
            if (IS_TOUCH_DEVICE) { // USING GLOBAL
                mobileControls.style.display = 'flex';
                if (uiLayer) uiLayer.style.justifyContent = 'space-between'; // HUD top, Controls bottom

                joystickRadius = joystick.offsetWidth / 2;
                updateJoystickCenter();

                joystick.addEventListener('touchstart', handleJoystickStart, {
                    passive: false
                });
                document.addEventListener('touchmove', handleTouchMove, {
                    passive: false
                });
                document.addEventListener('touchend', handleTouchEnd, {
                    passive: false
                });
                document.addEventListener('touchcancel', handleTouchEnd, {
                    passive: false
                });

                jumpButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.up = true;
                    jumpButton.style.transform = 'scale(0.9)';
                }, {
                    passive: false
                });

                jumpButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.up = false;
                    jumpButton.style.transform = 'scale(1)';
                }, {
                    passive: false
                });

                // New: Tap-to-move on canvas
                canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });

            } else {
                mobileControls.style.display = 'none';
                if (uiLayer) uiLayer.style.justifyContent = 'flex-end'; 
            }
        }

        function updateJoystickCenter() {
            const rect = joystick.getBoundingClientRect();
            joystickCenterX = rect.left + rect.width / 2;
            joystickCenterY = rect.top + rect.height / 2;
        }

        function handleJoystickStart(e) {
            e.preventDefault();
            if (joystickTouchId === null) {
                joystickActive = true;
                joystickTouchId = e.changedTouches[0].identifier;
                updateJoystickNub(e.changedTouches[0]);
            }
        }

        function handleTouchMove(e) {
            if (joystickActive) {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        e.preventDefault();
                        updateJoystickNub(touch);
                        break;
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (joystickActive) {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        joystickActive = false;
                        joystickTouchId = null;
                        resetJoystickNub();
                        keys.left = false;
                        keys.right = false;
                        keys.joystickRequestsUp = false; // Reset joystick jump request
                        break;
                    }
                }
            }
        }

        function updateJoystickNub(touch) {
            let dx = touch.clientX - joystickCenterX;
            let dy = touch.clientY - joystickCenterY;
            let distance = Math.sqrt(dx * dx + dy * dy);

            const maxNubDist = joystickRadius - 25;

            if (distance > maxNubDist) {
                let angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * maxNubDist;
                dy = Math.sin(angle) * maxNubDist;
            }

            joystickNub.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

            const threshold = 0.4; // Increased from 0.3 for less horizontal sensitivity
            const normalizedX = dx / maxNubDist;

            if (Math.abs(normalizedX) > threshold) {
                if (normalizedX > 0) {
                    keys.right = true;
                    keys.left = false;
                } else {
                    keys.left = true;
                    keys.right = false;
                }
            } else {
                keys.left = false;
                keys.right = false;
            }

            // Handle joystick up for jumping
            const yUpThreshold = -0.65; // Changed from -0.5 for less vertical sensitivity (requires more upward pull)
            const normalizedY = dy / maxNubDist;
            keys.joystickRequestsUp = (normalizedY < yUpThreshold);
        }

        function resetJoystickNub() {
            joystickNub.style.transform = 'translate(-50%, -50%)';
        }

        // New functions for canvas tap-to-move
        function handleCanvasTouchStart(e) {
            if (!joystickActive && e.changedTouches.length > 0) {
                e.preventDefault(); // Prevent default actions like scrolling/zooming
                // Consider the "latest" touch that started on the canvas for this event
                const touch = e.changedTouches[0]; // Taking the first changed touch in this event
                const touchX = touch.clientX;
                const canvasRect = canvas.getBoundingClientRect();
                const canvasCenterX = canvasRect.left + canvasRect.width / 2;

                // Check if the touch is within the canvas horizontal and vertical bounds
                if (touchX >= canvasRect.left && touchX <= canvasRect.right &&
                    touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom) {
                    if (touchX < canvasCenterX) {
                        keys.left = true;
                        keys.right = false;
                    } else {
                        keys.right = true;
                        keys.left = false;
                    }
                }
            }
        }

        function handleCanvasTouchEnd(e) {
            if (!joystickActive) {
                e.preventDefault(); // Prevent default actions

                let moveLeftBasedOnRemainingTouches = false;
                let moveRightBasedOnRemainingTouches = false;
                const canvasRect = canvas.getBoundingClientRect();
                const canvasCenterX = canvasRect.left + canvasRect.width / 2;

                // e.touches lists touches that are *still* active on the target element (canvas)
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const touchX = touch.clientX;

                    // Check if the *remaining* touch is within the canvas bounds
                    if (touchX >= canvasRect.left && touchX <= canvasRect.right &&
                        touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom) {
                        if (touchX < canvasCenterX) {
                            moveLeftBasedOnRemainingTouches = true;
                        } else {
                            moveRightBasedOnRemainingTouches = true;
                        }
                    }
                }

                // Update keys based on remaining touches
                // If a finger remains on the left, move left.
                // Else if a finger remains on the right, move right.
                // Otherwise, stop.
                if (moveLeftBasedOnRemainingTouches) {
                    keys.left = true;
                    keys.right = false;
                } else if (moveRightBasedOnRemainingTouches) {
                    keys.left = false;
                    keys.right = true;
                } else {
                    // No remaining active touches on either designated half of the canvas
                    keys.left = false;
                    keys.right = false;
                }
            }
        }

        function resizeCanvas() {
            // const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); DELETED - using global
            let newWidth, newHeight;

            if (IS_TOUCH_DEVICE) { // USING GLOBAL
                // Mobile: Use full window dimensions
                newWidth = window.innerWidth;
                newHeight = window.innerHeight;
            } else {
                // Desktop: Existing sizing logic with aspect ratio and max dimensions
                const aspectRatio = 16 / 9;
                let baseWidthPercentage = 0.95;
                let baseHeightPercentage = 0.85; // Desktop uses a smaller % of window height
                
                let maxWidth = 1280;
                let maxHeight = 720;

                newWidth = Math.min(window.innerWidth * baseWidthPercentage, maxWidth);
                newHeight = Math.min(window.innerHeight * baseHeightPercentage, maxHeight);

                // Maintain aspect ratio for desktop
                if (newWidth / newHeight > aspectRatio) {
                    newWidth = newHeight * aspectRatio;
                } else {
                    newHeight = newWidth / aspectRatio;
                }

                newWidth = Math.max(newWidth, 400);
                newHeight = Math.max(newHeight, 225);
            }

            gameContainer.style.width = `${newWidth}px`;
            gameContainer.style.height = `${newHeight}px`;
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Disable image smoothing for pixel art
            ctx.imageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;

            // Update UI scaling
            const baseFontSize = Math.max(14, Math.min(28, canvas.width / 35));
            scoreDisplay.style.fontSize = `${baseFontSize}px`;
            healthDisplay.style.fontSize = `${baseFontSize * 0.85}px`;

            const messageFontSize = Math.max(18, Math.min(36, canvas.width / 22));
            document.querySelectorAll('.game-message').forEach(el => {
                el.style.fontSize = `${messageFontSize}px`;
                el.querySelectorAll('button').forEach(btn => btn.style.fontSize = `${messageFontSize * 0.75}px`);
                el.querySelectorAll('p').forEach(p => p.style.fontSize = `${messageFontSize * 0.65}px`);
            });

            if (mobileControls.style.display === 'flex') {
                updateJoystickCenter();
            }

            if (camera) {
                camera.update();
            }
        }

        function resetGame() {
            if (player) player.health = 3;
            collectedGemsInLevel = 0;
            particles = [];
            screenShake = 0;
            loadLevel(currentLevel);
            gameState = 'playing';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            setupMobileControls();

            // Display saved progress
            const savedProgressString = localStorage.getItem('retroPixelSave');
            if (savedProgressString) {
                const savedProgress = JSON.parse(savedProgressString);
                if (savedProgress && savedProgress.level) {
                    gameProgress = savedProgress;
                    // Ensure health is present, default to maxHealth if loading an old save without it
                    if (gameProgress.health === undefined) {
                        gameProgress.health = 4; // Default to new max health
                    }
                    progressMessage.textContent = `Continue from Level ${gameProgress.level} of ${levels.length}? (Score: ${gameProgress.score}, Health: ${gameProgress.health}‚ù§Ô∏è)`;
                }
            } else {
                progressMessage.textContent = `Ready for ${levels.length} epic adventures! (Health: ${gameProgress.health}‚ù§Ô∏è)`;
            }

            startButton.onclick = () => {
                currentLevel = gameProgress.level;
                score = gameProgress.score;
                // Health will be set in loadLevel from gameProgress
                loadLevel(currentLevel);
                // soundtrack.play().catch(error => console.log("Error playing soundtrack:", error)); // Start soundtrack // Old call
                startSoundtrack();
                gameLoop(0);
            };

            restartButton.onclick = () => {
                currentLevel = 1;
                score = 0;
                gameProgress = {
                    level: 1,
                    score: 0,
                    health: 4 // Reset to full health
                };
                localStorage.setItem('retroPixelSave', JSON.stringify(gameProgress)); // Save reset progress
                resetGame(); // This will also handle soundtrack
                // if (soundtrack.paused) { // Ensure soundtrack plays on new game // Old logic
                //   soundtrack.play().catch(error => console.log("Error playing soundtrack on restart:", error));
                // } else {
                //   soundtrack.currentTime = 0; // Restart soundtrack
                // }
                // resetGame() already calls stop/start for the dummy soundtrack
            };

            nextLevelButton.onclick = () => {
                currentLevel++;
                if (currentLevel <= levels.length) {
                    resetGame(); // This will load the next level and handle soundtrack
                } else {
                    // Game completed all levels, loadLevel will show the victory screen
                    loadLevel(currentLevel); // Soundtrack is stopped in loadLevel for gameComplete
                }
            };

            resetGameButtonFromVictory.onclick = () => {
                if (animationId) { // Stop any existing game loop
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }

                currentLevel = 1;
                score = 0;
                gameProgress = {
                    level: 1,
                    score: 0,
                    health: 4 // Reset to full health for a new game
                };
                localStorage.setItem('retroPixelSave', JSON.stringify(gameProgress)); // Save fresh state

                levelCompleteScreen.style.display = 'none'; // Hide victory screen
                gameOverScreen.style.display = 'none';    // Ensure game over is hidden
                
                if (!player) player = new Player(0,0); // Temp player if null for health display
                progressMessage.textContent = `Ready for ${levels.length} epic adventures! (Health: ${gameProgress.health}‚ù§Ô∏è)`;
                startScreen.style.display = 'block'; // Show the initial start screen

                // soundtrack.pause(); // Ensure soundtrack is stopped // Old call
                // soundtrack.currentTime = 0; // Old call
                stopSoundtrack();

                gameState = 'start'; // Set game state back to the initial state
            };
        }

        init();
    </script>
</body>

</html>